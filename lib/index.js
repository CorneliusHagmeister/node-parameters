// Generated by CoffeeScript 2.0.2

/*
 * parameters(config)

## About options

Options are defined at the "config" level or for each command.

## About main

Main is what's left after the options. Like options, "main" is 
defined at the "config" level or for each command.

Parameters are defined with the following properties
*   name:     name of the two dash parameter in the command (eg "--my_name") and in the returned parse object unless label is defined.
*   label:    not yet implemented, see name
*   shortcut: name of the one dash parameter in the command (eg "-n"), must be one charactere
*   required: boolean, throw an exception when true and the parameter is not defined
*   type:     one of 'string', 'boolean', 'integer' or 'array'

 */
var Parameters, load, pad, types,
  indexOf = [].indexOf;

pad = require('pad');

load = require('./load');

types = ['string', 'boolean', 'integer', 'array'];

Parameters = function(config = {}) {
  var command, commands, i, len, makeCommand, options, ref;
  this.config = config;
  // Sanitize options
  options = function(command) {
    var fn, i, len, option, ref, results;
    ref = command.options;
    // Access option by key
    fn = function(option) {
      return command.options.__defineGetter__(option.name, function() {
        return option;
      });
    };
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      option = ref[i];
      fn(option);
      if (option.type == null) {
        option.type = 'string';
      }
      if (types.indexOf(option.type) === -1) {
        throw Error(`Invalid option type ${JSON.stringify(option.type)}`);
      }
      command.shortcuts[option.shortcut] = option.name;
      if (typeof options.one_of === 'string') {
        options.one_of = [options.one_of];
      }
      if (options.one_of && !Array.isArray(options.one_of)) {
        throw Error(`Invalid option one_of "${JSON.stringify(option.one_of)}"`);
      } else {
        results.push(void 0);
      }
    }
    return results;
  };
  // An object where key are command and values are object map between shortcuts and names
  config.shortcuts = {};
  if (config.options == null) {
    config.options = [];
  }
  options(config);
  if (config.command == null) {
    config.command = 'command';
  }
  if (config.commands == null) {
    config.commands = [];
  }
  if (!Array.isArray(config.commands)) {
    config.commands = [config.commands];
  }
  makeCommand = function(command) {
    config.commands.__defineGetter__(command.name, function() {
      return command;
    });
    if (command.strict == null) {
      command.strict = config.strict;
    }
    command.shortcuts = {};
    if (command.options == null) {
      command.options = [];
    }
    if (!Array.isArray(command.options)) {
      command.options = [command.options];
    }
    return options(command);
  };
  ref = config.commands;
  for (i = 0, len = ref.length; i < len; i++) {
    command = ref[i];
    makeCommand(command);
  }
  if (!config.commands.help) {
    if (config.commands.length) {
      commands = {
        name: 'help',
        description: `Display help information about ${config.name}`,
        main: {
          name: 'name',
          description: 'Help about a specific command'
        }
      };
      config.commands.push(commands);
      makeCommand(commands);
    } else {
      config.options.push({
        name: 'help',
        shortcut: 'h',
        description: "Display help information"
      });
    }
  }
  return this;
};

/*

## `run([argv])`

Parse the arguments and execute the module defined by the "module" option.

You should only pass the parameters and the not the script name.

Example

result = parameters(
  commands: [
    name: 'start'
    run: function(){ return 'something'; }
    options: [
      name: 'debug'
    ]
  ]
).run ['start', '-d', 'Hello']

 */
Parameters.prototype.run = function(argv = process, ...args) {
  var params, run;
  params = this.parse(argv);
  if (params[this.config.command]) {
    run = this.config.commands[params[this.config.command]].run;
    if (!run) {
      throw Error(`Missing run definition for command ${JSON.stringify(params[this.config.command])}`);
    }
  } else {
    run = this.config.run;
    if (!run) {
      throw Error('Missing run definition');
    }
  }
  if (typeof run === 'string') {
    // Load the module
    run = this.load(run);
  }
  return run.call(this, ...args, params, argv, this.config);
};

/*

## `load(module)`

Load and return a module, use `require.main.require` by default.

 */
Parameters.prototype.load = function(module) {
  if (!this.config.load) {
    return load(module);
  } else {
    if (typeof this.config.load === 'string') {
      return load(this.config.load)(module);
    } else {
      return this.config.load(module);
    }
  }
};

/*

## `parse([argv])`

Convert process arguments into a usable object. Argument may
be in the form of a string or an array. If not provided, it 
parse the arguments present in  `process.argv`.

You should only pass the parameters and the not the script name.

Example

  params = argv.parse ['start', '--watch', __dirname, '-s', 'my', '--command']
  params.should.eql
    action: 'start'
    watch: __dirname
    strict: true
    command: 'my --command'

 */
Parameters.prototype.parse = function(argv = process) {
  var config, i, index, j, len, len1, name, name1, option, params, parse, ref, ref1;
  if (typeof argv === 'string') {
    argv = argv.split(' ');
  }
  index = 0;
  // Remove node and script argv elements
  if (argv === process) {
    index = 2;
    argv = argv.argv;
  }
  // Extracted parameters
  params = {};
  parse = (config) => {
    var i, j, key, len, len1, main, option, options, ref, ref1, shortcut, type, value, values;
    // Read options
    while (true) {
      if (argv.length === index || argv[index][0] !== '-') {
        break;
      }
      key = argv[index++];
      shortcut = key[1] !== '-';
      key = key.substring((shortcut ? 1 : 2), key.length);
      if (shortcut) {
        shortcut = key;
      }
      if (shortcut) {
        key = config.shortcuts[shortcut];
      }
      option = (ref = config.options) != null ? ref[key] : void 0;
      if (!shortcut && config.strict && !option) {
        throw Error(`Invalid option ${JSON.stringify(key)}`);
      }
      if (shortcut && !option) {
        throw Error(`Invalid shortcut '${shortcut}'`);
      }
      // Auto discovery
      if (!option) {
        type = argv[index] && argv[index][0] !== '-' ? 'string' : 'boolean';
        option = {
          name: key,
          type: type
        };
      }
      switch (option.type) {
        case 'boolean':
          params[key] = true;
          break;
        case 'string':
          value = argv[index++];
          if (value == null) {
            throw Error(`Invalid Option: no value found for option ${JSON.stringify(key)}`);
          }
          if (value[0] === '-') {
            throw Error(`Invalid Option: no value found for option ${JSON.stringify(key)}`);
          }
          params[key] = value;
          break;
        case 'integer':
          value = argv[index++];
          if (value == null) {
            throw Error(`Invalid Option: no value found for option ${JSON.stringify(key)}`);
          }
          if (value[0] === '-') {
            throw Error(`Invalid Option: no value found for option ${JSON.stringify(key)}`);
          }
          params[key] = parseInt(value, 10);
          break;
        case 'array':
          value = argv[index++];
          if (value == null) {
            throw Error(`Invalid Option: no value found for option ${JSON.stringify(key)}`);
          }
          if (value[0] === '-') {
            throw Error(`Invalid Option: no value found for option ${JSON.stringify(key)}`);
          }
          if (params[key] == null) {
            params[key] = [];
          }
          params[key].push(...value.split(','));
      }
    }
    // Check against required options
    options = config.options;
    if (options) {
      for (i = 0, len = options.length; i < len; i++) {
        option = options[i];
        if (option.required) {
          if (!(params.help || (params[option.name] != null))) {
            throw Error(`Required option argument "${option.name}"`);
          }
        }
        if (option.one_of) {
          values = params[option.name];
          if (!Array.isArray(values)) {
            values = [values];
          }
          for (j = 0, len1 = values.length; j < len1; j++) {
            value = values[j];
            if (indexOf.call(option.one_of, value) < 0) {
              throw Error(`Invalid value "${value}" for option "${option.name}"`);
            }
          }
        }
      }
    }
    // We still have some argument to parse
    if (argv.length !== index) {
      // Store the full command in the return object
      main = argv.slice(index).join(' ');
      if (config.main) {
        params[config.main.name] = main;
      } else {
        if ((ref1 = config.commands) != null ? ref1[argv[index]] : void 0) {
          config = this.config.commands[argv[index]];
          params[this.config.command] = argv[index++];
          parse(config, argv);
        } else {
          throw Error(`Fail to parse end of command "${main}"`);
        }
      }
    }
    // Command mode but no command are found, default to help
    // Happens with global options without a command
    if (this.config.commands.length && !params[this.config.command]) {
      params[this.config.command] = 'help';
    }
    // Check against required main
    main = config.main;
    if (main) {
      if (main.required) {
        if (params[main.name] == null) {
          throw Error(`Required main argument "${main.name}"`);
        }
      }
    }
    return params;
  };
  // If they are commands (other than help) and no arguments are provided,
  // we default to the help action
  if (this.config.commands.length && argv.length === index) {
    argv.push('help');
  }
  if (this.config.commands.length && argv[index].substr(0, 1) !== '-') {
    config = this.config.commands[argv[index]];
    if (!config) {
      throw Error(`Invalid command '${argv[index]}'`);
    }
    params[this.config.command] = argv[index++];
  } else {
    config = this.config;
  }
  params = parse(config, argv);
  // Enrich params with default values
  if (params[this.config.command]) {
    ref = this.config.commands[params[this.config.command]].options;
    for (i = 0, len = ref.length; i < len; i++) {
      option = ref[i];
      if (option.default != null) {
        if (params[name = option.name] == null) {
          params[name] = option.default;
        }
      }
    }
  }
  ref1 = this.config.options;
  for (j = 0, len1 = ref1.length; j < len1; j++) {
    option = ref1[j];
    if (option.default != null) {
      if (params[name1 = option.name] == null) {
        params[name1] = option.default;
      }
    }
  }
  return params;
};

/*

## `stringify([script], params)`

Convert an object into process arguments.

 */
Parameters.prototype.stringify = function(params, options = {}) {
  var argv, config, i, j, key, keys, len, len1, name, name1, option, ref, ref1, stringify, value;
  argv = options.script ? [process.execPath, options.script] : [];
  keys = {};
  // Validate command
  if (params[this.config.command]) {
    if (!this.config.commands[params[this.config.command]]) {
      throw Error(`Invalid command '${params[this.config.command]}'`);
    }
  }
  // Enrich params with default values
  if (params[this.config.command]) {
    ref = this.config.commands[params[this.config.command]].options;
    for (i = 0, len = ref.length; i < len; i++) {
      option = ref[i];
      if (option.default != null) {
        if (params[name = option.name] == null) {
          params[name] = option.default;
        }
      }
    }
  }
  ref1 = this.config.options;
  for (j = 0, len1 = ref1.length; j < len1; j++) {
    option = ref1[j];
    if (option.default != null) {
      if (params[name1 = option.name] == null) {
        params[name1] = option.default;
      }
    }
  }
  // Stringify
  stringify = (config) => {
    var k, key, l, len2, len3, ref2, val, value;
    ref2 = config.options;
    for (k = 0, len2 = ref2.length; k < len2; k++) {
      option = ref2[k];
      key = option.name;
      keys[key] = true;
      value = params[key];
      if (option.required && (value == null)) {
        // Validate required value
        throw Error(`Required option argument "${key}"`);
      }
      // Validate value against option "one_of"
      if ((value != null) && option.one_of) {
        if (!Array.isArray(value)) {
          value = [value];
        }
        for (l = 0, len3 = value.length; l < len3; l++) {
          val = value[l];
          if (indexOf.call(option.one_of, val) < 0) {
            throw Error(`Invalid value "${val}" for option "${option.name}"`);
          }
        }
      }
      // Serialize
      if (value) {
        switch (option.type) {
          case 'boolean':
            argv.push(`--${key}`);
            break;
          case 'string':
          case 'integer':
            argv.push(`--${key}`);
            argv.push(`${value}`);
            break;
          case 'array':
            argv.push(`--${key}`);
            argv.push(`${value.join(',')}`);
        }
      }
    }
    if (config.main) {
      value = params[config.main.name];
      if (config.main.required && (value == null)) {
        throw Error(`Required main argument "${config.main.name}"`);
      }
      keys[config.main.name] = value;
      if (value != null) {
        return argv.push(value);
      }
    }
  };
  stringify(this.config);
  if (params[this.config.command]) {
    config = this.config.commands[params[this.config.command]];
    argv.push(params[this.config.command]);
    keys[this.config.command] = params[this.config.command];
    stringify(config);
  }
  // Check keys
  for (key in params) {
    value = params[key];
    if (keys[key]) {
      continue;
    }
    if (this.config.strict) {
      throw Error(`Invalid option ${JSON.stringify(key)}`);
    }
    if (typeof value === 'boolean') {
      if (value) {
        argv.push(`--${key}`);
      }
    } else if (typeof value === 'undefined' || value === null) {

    } else {
      // nothing
      argv.push(`--${key}`);
      argv.push(`${value}`);
    }
  }
  return argv;
};

/*

## `help([command])`

Return a string describing the usage of the overall command or one of its
command.

 */
Parameters.prototype.help = function(command) {
  var config, content, describeCommand, describeOption, i, j, k, len, len1, len2, main, option, options, ref, ref1, ref2, synopsis;
  config = this.config.commands[command];
  if ((command != null) && !config) {
    throw Error(`Invalid command "${command}"`);
  }
  describeOption = function(option, pad_option, pad_description) {
    var content, shortcut;
    shortcut = option.shortcut ? `-${option.shortcut} ` : '';
    content = ' '.repeat(pad_option);
    content += pad(`${shortcut}--${option.name}`, pad_description - pad_option);
    content += option.description;
    return content += '\n';
  };
  describeCommand = function(config) {
    var content, i, len, option, ref;
    content = pad(`    ${config.name}`, 24);
    content += config.description;
    content += '\n';
    if (config.options) {
      ref = config.options;
      for (i = 0, len = ref.length; i < len; i++) {
        option = ref[i];
        content += describeOption(option, 6, 26);
      }
    }
    if (config.main) {
      content += pad(`      ${config.main.name}`, 26);
      content += config.main.description;
      content += '\n';
    }
    return content;
  };
  if (command && command !== 'help') {
    // Command help
    config = this.config.commands[command];
    synopsis = this.config.name + ' ' + command;
    if (config.options.length) {
      options = 'options...';
      if (!(config.options.filter(function(o) {
        return o.required;
      })).length) {
        options = `[${options}]`;
      }
      synopsis += ` ${options}`;
    }
    if (config.main) {
      main = `${config.main.name}`;
      if (!config.main.required) {
        main = `[${main}]`;
      }
      synopsis += ` ${main}`;
    }
    content = `NAME\n    ${this.config.name} ${command} - ${config.description}\nSYNOPSIS\n    ${synopsis}\nDESCRIPTION\n`;
    return content += describeCommand(config);
  } else {
    // Full help
    content = `NAME\n    ${this.config.name} - ${this.config.description}\n`;
    content += 'SYNOPSIS\n';
    content += `    ${this.config.name}`;
    if (this.config.commands.length) {
      content += ' command';
    }
    content += ' [options...]';
    content += '\n';
    if (this.config.commands.length) {
      content += '    where command is one of';
      content += '\n';
    }
    ref = this.config.commands;
    for (i = 0, len = ref.length; i < len; i++) {
      command = ref[i];
      content += pad(`      ${command.name}`, 24);
      content += command.description;
      content += '\n';
    }
    content += 'DESCRIPTION\n';
    ref1 = this.config.options;
    // Describe each option
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      option = ref1[j];
      content += describeOption(option, 4, 24);
    }
    // shortcut = if option.shortcut then "-#{option.shortcut} " else ''
    // content += pad "    #{shortcut}--#{option.name}", 24
    // content += option.description
    // content += '\n'
    if (this.config.main) {
      content += pad(`    ${this.config.main.name}`, 24);
      content += this.config.main.description;
      content += '\n';
    }
    ref2 = this.config.commands;
    // Describe each command
    for (k = 0, len2 = ref2.length; k < len2; k++) {
      command = ref2[k];
      content += describeCommand(command);
    }
    // Add examples
    content += 'EXAMPLES\n';
    if (this.config.commands.length) {
      content += `    ${this.config.name} help       Show this message`;
    } else {
      content += `    ${this.config.name} --help     Show this message`;
    }
    content += '\n';
    return content;
  }
};

module.exports = function(config) {
  return new Parameters(config);
};

module.exports.Parameters = Parameters;
