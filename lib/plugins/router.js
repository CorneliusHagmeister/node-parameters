// Generated by CoffeeScript 2.4.1
// ## `route(argv)` or `route(params)` or `route(process)`

// * `cli_arguments`: `[string] | process` The arguments to parse into parameters, accept the [Node.js process](https://nodejs.org/api/process.html) instance or an [argument list](https://nodejs.org/api/process.html#process_process_argv) provided as an array of strings, optional, default to `process`.
// * `...users_arguments`: `any` Any arguments that will be passed to the executed function associated with a route.
// * Returns: `any` Whatever the route function returns.

// How to use the `route` method to execute code associated with a particular command.

// Dependecies
var Parameters, clone, error, is_object_literal, merge, path;

path = require('path');

error = require('../utils/error');

({clone, merge, is_object_literal} = require('mixme'));

// Parameters & plugins
Parameters = require('../Parameters');

require('../plugins/config');

Parameters.prototype.configure = (function(parent) {
  return function() {
    var config, sanitize_commands, sanitize_help, sanitize_route;
    config = parent.call(this, ...arguments);
    if (arguments.length === 0) {
      return config;
    }
    config = this.config;
    sanitize_help = function(config) {
      var base, base1, base2, command, ref, ref1;
      return;
      if (config.help == null) {
        config.help = {};
      }
      if ((base = config.help).writer == null) {
        base.writer = 'stderr';
      }
      if ((base1 = config.help).end == null) {
        base1.end = false;
      }
      if ((base2 = config.help).route == null) {
        base2.route = path.resolve(__dirname, './routes/help');
      }
      if (typeof config.help.writer === 'string') {
        if ((ref = config.help.writer) !== 'stdout' && ref !== 'stderr') {
          throw error(['Invalid Help Configuration:', 'accepted values are ["stdout", "stderr"] when writer is a string,', `got ${JSON.stringify(config.help.writer)}`]);
        }
      } else if (!(config.help.writer instanceof stream.Writable)) {
        if ((ref1 = config.help.writer) !== 'stdout' && ref1 !== 'stderr') {
          throw error(["Invalid Help Configuration:", "writer must be a string or an instance of stream.Writer,", `got ${JSON.stringify(config.help.writer)}`]);
        }
      }
      if (Object.keys(config.commands).length) {
        if (config.command == null) {
          config.command = 'command';
        }
        command = sanitize_command({
          name: 'help',
          description: `Display help information about ${config.name}`,
          command: ['help'],
          main: {
            name: 'name',
            description: 'Help about a specific command'
          },
          help: true,
          route: config.help.route
        }, config);
        return config.commands[command.name] = merge(command, config.commands[command.name]);
      }
    };
    sanitize_help(this.config);
    sanitize_route = function(config) {
      var ref;
      if (!config.route) {
        return config;
      }
      if ((ref = typeof config.route) !== 'function' && ref !== 'string') {
        throw error(['Invalid Route Configuration:', "accept string or function", !Array.isArray(config.command) ? "in application," : void 0, Array.isArray(config.command) ? `in command ${JSON.stringify(config.command.join(' '))},` : void 0, `got ${JSON.stringify(config.route)}`]);
      }
    };
    sanitize_commands = function(config) {
      var _, command, ref, results;
      ref = config.commands;
      results = [];
      for (_ in ref) {
        command = ref[_];
        sanitize_route(command);
        results.push(sanitize_commands(command));
      }
      return results;
    };
    sanitize_route(config);
    sanitize_commands(config);
    return config;
  };
})(Parameters.prototype.configure);

Parameters.prototype.route = function(argv = process, ...args) {
  var commands, config, configure, err, i, params, route, route_error;
  route_error = (err, commands) => {
    var params, route;
    argv = commands.length ? ['help', ...commands] : ['--help'];
    params = this.parse(argv);
    route = this.load(this.config.help.route);
    return route.call(this, {
      argv: argv,
      config: this.config,
      params: params,
      error: err
    }, ...args);
  };
  // Normalize arguments
  if (Array.isArray(argv)) {
    try {
      params = this.parse(argv);
    } catch (error1) {
      err = error1;
      return route_error(err, err.command || []);
    }
  } else if (argv === process) {
    try {
      params = this.parse(argv);
    } catch (error1) {
      err = error1;
      return route_error(err, err.command || []);
    }
  } else {
    throw error(['Invalid Arguments:', 'first argument must be an argv array or the process object,', `got ${JSON.stringify(argv)}`]);
  }
  route = (config, commands) => {
    route = config.route;
    if (!route) {
      // Provide an error message if leaf command does not define any route
      if (!(Object.keys(config.commands).length || route)) {
        err = config.root ? error(['Missing Application Route:', 'a \"route\" definition is required when no commands are defined']) : error(['Missing Command Route:', `a "route" definition ${JSON.stringify(params[this.config.command])} is required when no child commands are defined`]);
      }
      // Convert argument to an help command
      argv = commands.length ? ['help', ...commands] : ['--help'];
      params = this.parse(argv);
      route = this.load(this.config.help.route);
    } else {
      if (typeof route === 'string') {
        route = this.load(route);
      }
    }
    return route.call(this, {
      argv: argv,
      config: this.config,
      params: params,
      error: err
    }, ...args);
  };
  // Print help
  if (commands = this.helping(params)) {
    route = this.load(this.config.help.route);
    route.call(this, {
      argv: argv,
      config: this.config,
      params: params
    }, ...args);
  // Load a command route
  } else if (commands = params[this.config.command]) {
    if (this.config.extended) {
      // TODO: not tested yet, construct a commands array like in flatten mode when extended is activated
      commands = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = params.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          results.push(params[i][this.config.command]);
        }
        return results;
      }).call(this);
    }
    config = (configure = function(config, commands) {
      config = config.commands[commands.shift()];
      if (commands.length) {
        return configure(config, commands);
      } else {
        return config;
      }
    })(this.config, clone(commands));
    return route(config, commands);
  } else {
    // Load an application route
    return route(this.config, []);
  }
};
