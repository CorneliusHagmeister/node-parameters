// Generated by CoffeeScript 2.4.1
  // {Parameters} = require './Parameters'
var Parameters, builder_main, clone, commands_builder, error, is_object_literal, merge, mutate, options_builder, types,
  indexOf = [].indexOf;

Parameters = require('../Parameters');

error = require('../utils/error');

({clone, is_object_literal, merge, mutate} = require('mixme'));

commands_builder = function(pcommand) {
  var builder;
  builder = (command) => {
    var base, ctx, i, lconfig, len, name;
    ctx = this;
    if (typeof command === 'string') {
      command = [command];
    }
    command = [...pcommand, ...command];
    lconfig = this.config;
    for (i = 0, len = command.length; i < len; i++) {
      name = command[i];
      // A new command doesn't have a config registered yet
      if ((base = lconfig.commands)[name] == null) {
        base[name] = {};
      }
      lconfig = lconfig.commands[name];
    }
    return {
      commands: commands_builder.call(this, command),
      options: options_builder.call(this, lconfig),
      get: function() {
        return lconfig;
      },
      set: function() {
        var j, len1, values;
        values = null;
        if (arguments.length === 2) {
          values = {
            [arguments[0]]: arguments[1]
          };
        } else if (arguments.length === 1) {
          values = arguments[0];
        } else {
          throw error(['Invalid Commands Set Arguments:', 'expect 1 or 2 arguments, got 0']);
        }
        lconfig = ctx.config;
        for (j = 0, len1 = command.length; j < len1; j++) {
          name = command[j];
          // A new command doesn't have a config registered yet
          // lconfig.commands[name] ?= {}
          lconfig = lconfig.commands[name];
        }
        mutate(lconfig, values);
        ctx.hook('configure_commands_set', {
          config: lconfig,
          command: command,
          values: values
        }, ({config, command, values}) => {
          var k, ref, ref1, results, v;
          config.name = name;
          ref = config.options;
          // config.options ?= {}
          for (k in ref) {
            v = ref[k];
            this.options(k).set(v);
          }
          ref1 = config.commands;
          results = [];
          for (k in ref1) {
            v = ref1[k];
            results.push(this.commands(k).set(v));
          }
          return results;
        });
        return this;
      },
      remove: function() {
        return delete lconfig.options[command];
      },
      show: function() {
        return lconfig;
      }
    };
  };
  return builder;
};

options_builder = function(config) {
  var builder;
  builder = function(name) {
    return {
      get: function(properties) {
        var i, len, options, property;
        if (typeof properties === 'string') {
          properties = [properties];
        }
        if (Array.isArray(properties)) {
          options = {};
          for (i = 0, len = properties.length; i < len; i++) {
            property = properties[i];
            options[property] = config.options[name][property];
          }
          return options;
        } else {
          return config.options[name];
        }
      },
      remove: function(name) {
        return delete config.options[name];
      },
      set: function() {
        var option, ref, values;
        values = null;
        if (arguments.length === 2) {
          values = {
            [arguments[0]]: arguments[1]
          };
        } else if (arguments.length === 1) {
          values = arguments[0];
        } else {
          throw error(['Invalid Commands Set Arguments:', 'expect 1 or 2 arguments, got 0']);
        }
        option = config.options[name] = merge(config.options[name], values);
        // Normalize option
        option.name = name;
        if (option.type == null) {
          option.type = 'string';
        }
        if (ref = option.type, indexOf.call(types, ref) < 0) {
          throw error(['Invalid Option Configuration:', `supported options types are ${JSON.stringify(types)},`, `got ${JSON.stringify(option.type)}`, `for option ${JSON.stringify(name)}`, Array.isArray(config.command) ? `in command ${JSON.stringify(config.command.join(' '))}` : void 0]);
        }
        if (option.shortcut) {
          config.shortcuts[option.shortcut] = option.name;
        }
        if (typeof option.one_of === 'string') {
          option.one_of = [option.one_of];
        }
        if (option.one_of && !Array.isArray(option.one_of)) {
          throw error(['Invalid Option Configuration:', 'option property "one_of" must be a string or an array,', `got ${option.one_of}`]);
        }
        return this;
      }
    };
  };
  builder.__proto__ = {
    list: function() {
      return Object.keys(config.options);
    },
    get: function(name) {
      return config.options[name];
    }
  };
  return builder;
};

Parameters.prototype.configure = (function(parent) {
  return function() {
    if (arguments.length) {
      return parent.call(this, ...arguments);
    }
    parent.set = () => {
      return this.hook('configure_app_set', {
        config: this.config
      }, () => {
        var base, k, ref, ref1, results, v;
        if ((base = this.config).options == null) {
          base.options = {};
        }
        ref = this.config.options;
        for (k in ref) {
          v = ref[k];
          parent.options(k).set(v);
        }
        ref1 = this.config.commands;
        results = [];
        for (k in ref1) {
          v = ref1[k];
          results.push(parent.commands(k).set(v));
        }
        return results;
      });
    };
    parent.get = () => {
      return this.config;
    };
    parent.options = options_builder.call(this, this.config);
    parent.commands = commands_builder.call(this, this.config);
    parent.show = function() {
      return this.config;
    };
    return parent;
  };
})(Parameters.prototype.configure);


// ## Internal types
types = ['string', 'boolean', 'integer', 'array'];
