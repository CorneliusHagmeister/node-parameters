// Generated by CoffeeScript 2.4.1
  // {Parameters} = require './Parameters'
var Parameters, builder_main, clone, commands_builder, error, is_object_literal, merge, mutate, options_builder, types,
  indexOf = [].indexOf;

Parameters = require('../Parameters');

error = require('../utils/error');

({clone, is_object_literal, merge, mutate} = require('mixme'));

commands_builder = function(pcommand) {
  var builder;
  builder = (command) => {
    var base, ctx, i, lconfig, len, name;
    ctx = this;
    if (typeof command === 'string') {
      command = [command];
    }
    command = [...pcommand, ...command];
    lconfig = this.config;
    for (i = 0, len = command.length; i < len; i++) {
      name = command[i];
      // A new command doesn't have a config registered yet
      if ((base = lconfig.commands)[name] == null) {
        base[name] = {};
      }
      lconfig = lconfig.commands[name];
    }
    return {
      commands: commands_builder.call(this, command),
      main: builder_main.call(this, lconfig),
      options: options_builder.call(this, command),
      get: function() {
        var config, j, len1;
        config = ctx.config;
        for (j = 0, len1 = command.length; j < len1; j++) {
          name = command[j];
          if (!config.commands[name]) {
            throw Error('Invalid Command');
          }
          config = config.commands[name];
        }
        return config;
      },
      set: function() {
        var j, len1, values;
        values = null;
        if (arguments.length === 2) {
          values = {
            [arguments[0]]: arguments[1]
          };
        } else if (arguments.length === 1) {
          values = arguments[0];
        } else {
          throw error(['Invalid Commands Set Arguments:', 'expect 1 or 2 arguments, got 0']);
        }
        lconfig = ctx.config;
        for (j = 0, len1 = command.length; j < len1; j++) {
          name = command[j];
          // A new command doesn't have a config registered yet
          // lconfig.commands[name] ?= {}
          lconfig = lconfig.commands[name];
        }
        mutate(lconfig, values);
        ctx.hook('configure_commands_set', {
          config: lconfig,
          command: command,
          values: values
        }, ({config, command, values}) => {
          var k, ref, ref1, v;
          config.name = name;
          ref = config.options;
          // config.options ?= {}
          for (k in ref) {
            v = ref[k];
            this.options(k).set(v);
          }
          ref1 = config.commands;
          for (k in ref1) {
            v = ref1[k];
            this.commands(k).set(v);
          }
          return this.main.set(config.main);
        });
        return this;
      },
      remove: function() {
        return delete lconfig.options[command];
      },
      show: function() {
        return lconfig;
      }
    };
  };
  return builder;
};

builder_main = function(config) {
  var builder;
  builder = {};
  builder.get = function() {
    return config.main;
  };
  builder.set = function(value) {
    if (value === void 0) {
      // Do nothing if value is undefined
      return builder;
    }
    // Unset the property if null
    if (value === null) {
      config.main = void 0;
      return builder;
    }
    if (typeof value === 'string') {
      value = {
        name: value
      };
    }
    config.main = value;
    return builder;
  };
  return builder;
};

options_builder = function(commands) {
  var builder, ctx;
  ctx = this;
  builder = function(name) {
    return {
      get: function(properties) {
        var command, config, i, j, len, len1, options, property;
        options = {};
        for (i = 0, len = commands.length; i < len; i++) {
          command = commands[i];
          config = ctx.configure().commands(command).get();
        }
        config = ctx.configure().commands(commands).get();
        if (typeof properties === 'string') {
          properties = [properties];
        }
        if (Array.isArray(properties)) {
          for (j = 0, len1 = properties.length; j < len1; j++) {
            property = properties[j];
            options[property] = config.options[name][property];
          }
          return options;
        } else {
          return config.options[name];
        }
      },
      remove: function(name) {
        var config;
        config = ctx.configure().commands(commands).get();
        return delete config.options[name];
      },
      set: function() {
        var config, option, ref, values;
        config = ctx.configure().commands(commands).get();
        values = null;
        if (arguments.length === 2) {
          values = {
            [arguments[0]]: arguments[1]
          };
        } else if (arguments.length === 1) {
          values = arguments[0];
        } else {
          throw error(['Invalid Commands Set Arguments:', 'expect 1 or 2 arguments, got 0']);
        }
        option = config.options[name] = merge(config.options[name], values);
        // Normalize option
        option.name = name;
        if (option.type == null) {
          option.type = 'string';
        }
        if (ref = option.type, indexOf.call(types, ref) < 0) {
          throw error(['Invalid Option Configuration:', `supported options types are ${JSON.stringify(types)},`, `got ${JSON.stringify(option.type)}`, `for option ${JSON.stringify(name)}`, Array.isArray(config.command) ? `in command ${JSON.stringify(config.command.join(' '))}` : void 0]);
        }
        if (option.shortcut) {
          config.shortcuts[option.shortcut] = option.name;
        }
        if (typeof option.one_of === 'string') {
          option.one_of = [option.one_of];
        }
        if (option.one_of && !Array.isArray(option.one_of)) {
          throw error(['Invalid Option Configuration:', 'option property "one_of" must be a string or an array,', `got ${option.one_of}`]);
        }
        return this;
      }
    };
  };
  builder.__proto__ = {
    // get: (name) ->
    //   config = ctx.configure().commands(commands).get()
    //   config.options[name]
    get_cascaded: function() {
      var command, config, i, len, name, option, options, ref;
      options = {};
      config = ctx.config;
      for (i = 0, len = commands.length; i < len; i++) {
        command = commands[i];
        ref = config.options;
        for (name in ref) {
          option = ref[name];
          if (!option.cascade) {
            continue;
          }
          options[name] = option;
        }
        config = config.commands[command];
      }
      return options;
    },
    list: function() {
      var config;
      config = ctx.configure().commands(commands).get();
      return Object.keys(config.options);
    }
  };
  return builder;
};

Parameters.prototype.configure = (function(parent) {
  return function() {
    if (arguments.length) {
      return parent.call(this, ...arguments);
    }
    parent.set = () => {
      return this.hook('configure_app_set', {
        config: this.config
      }, () => {
        var base, k, ref, ref1, v;
        if ((base = this.config).options == null) {
          base.options = {};
        }
        ref = this.config.options;
        for (k in ref) {
          v = ref[k];
          parent.options(k).set(v);
        }
        ref1 = this.config.commands;
        for (k in ref1) {
          v = ref1[k];
          parent.commands(k).set(v);
        }
        return parent.main.set(this.config.main);
      });
    };
    parent.get = () => {
      return this.config;
    };
    parent.commands = commands_builder.call(this, []);
    parent.main = builder_main.call(this, this.config);
    parent.options = options_builder.call(this, []);
    parent.show = function() {
      return this.config;
    };
    return parent;
  };
})(Parameters.prototype.configure);


// ## Internal types
types = ['string', 'boolean', 'integer', 'array'];
