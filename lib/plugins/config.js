// Generated by CoffeeScript 2.4.1
  // {Parameters} = require './Parameters'
var Parameters, builder_main, clone, commands_builder, error, is_object_literal, merge, mutate, options_builder, types,
  indexOf = [].indexOf;

Parameters = require('../Parameters');

error = require('../utils/error');

({clone, is_object_literal, merge, mutate} = require('mixme'));

commands_builder = function(pcommand) {
  var builder, ctx;
  ctx = this;
  builder = (command) => {
    var base, j, lconfig, len, name;
    if (typeof command === 'string') {
      command = [command];
    }
    command = [...pcommand, ...command];
    lconfig = this.config;
    for (j = 0, len = command.length; j < len; j++) {
      name = command[j];
      // A new command doesn't have a config registered yet
      if ((base = lconfig.commands)[name] == null) {
        base[name] = {};
      }
      lconfig = lconfig.commands[name];
    }
    return {
      commands: commands_builder.call(this, command),
      main: builder_main.call(this, command),
      options: options_builder.call(this, command),
      get: function() {
        var _, base1, config, l, len1, option, ref, ref1, source;
        source = ctx.config;
        for (l = 0, len1 = command.length; l < len1; l++) {
          name = command[l];
          if (!source.commands[name]) {
            throw Error('Invalid Command');
          }
          // A new command doesn't have a config registered yet
          if ((base1 = source.commands)[name] == null) {
            base1[name] = {};
          }
          source = source.commands[name];
        }
        config = clone(source);
        if (command.length) {
          config.command = command;
        }
        ref = config.commands;
        for (name in ref) {
          _ = ref[name];
          config.commands[name] = this.commands(name).get();
        }
        config.options = this.options.show();
        config.shortcuts = {};
        ref1 = config.options;
        for (name in ref1) {
          option = ref1[name];
          if (option.shortcut) {
            config.shortcuts[option.shortcut] = option.name;
          }
        }
        if (config.main != null) {
          config.main = this.main.get();
        }
        return config;
      },
      set: function() {
        var hook, l, len1, values;
        values = null;
        if (arguments.length === 2) {
          values = {
            [arguments[0]]: arguments[1]
          };
        } else if (arguments.length === 1) {
          values = arguments[0];
        } else {
          throw error(['Invalid Commands Set Arguments:', 'expect 1 or 2 arguments, got 0']);
        }
        lconfig = ctx.config;
        for (l = 0, len1 = command.length; l < len1; l++) {
          name = command[l];
          // A new command doesn't have a config registered yet
          // lconfig.commands[name] ?= {}
          lconfig = lconfig.commands[name];
        }
        mutate(lconfig, values);
        hook = !command.length ? 'configure_app_set' : 'configure_commands_set';
        ctx.hook(hook, {
          config: lconfig,
          command: command,
          values: values
        }, ({config, command, values}) => {
          var k, ref, ref1, v;
          if (!command.length) {
            if (config.extended == null) {
              config.extended = false;
            }
            if (typeof config.extended !== 'boolean') {
              throw error(['Invalid Configuration:', 'extended must be a boolean,', `got ${JSON.stringify(config.extended)}`]);
            }
            config.root = true;
            if (config.name == null) {
              config.name = 'myapp';
            }
            if (Object.keys(config.commands).length) {
              if (config.command == null) {
                config.command = 'command';
              }
            }
          } else {
            if (config.name && config.name !== command.slice(-1)[0]) {
              throw error(['Incoherent Command Name:', `key ${JSON.stringify(name)} is not equal with name ${JSON.stringify(config.name)}`]);
            }
            if (config.command != null) {
              throw error(['Invalid Command Configuration:', 'command property can only be declared at the application level,', `got command ${JSON.stringify(config.command)}`]);
            }
            if (config.extended != null) {
              // config.command = command
              throw error(['Invalid Command Configuration:', 'extended property cannot be declared inside a command']);
            }
          }
          config.name = name;
          // config.description ?= 'No description yet' # Shall be moved to the help plugin
          if (config.commands == null) {
            config.commands = {};
          }
          if (config.options == null) {
            config.options = {};
          }
          if (config.shortcuts == null) {
            config.shortcuts = {};
          }
          if (config.strict == null) {
            config.strict = (function(config) {
              var len2, m, strict;
              strict = config.strict || false;
              for (m = 0, len2 = command.length; m < len2; m++) {
                name = command[m];
                config = config.commands[name];
                if (config.strict != null) {
                  strict = config.strict;
                }
              }
              return strict;
            })(ctx.confx().raw());
          }
          ref = config.options;
          // config.options ?= {}
          for (k in ref) {
            v = ref[k];
            this.options(k).set(v);
          }
          ref1 = config.commands;
          for (k in ref1) {
            v = ref1[k];
            this.commands(k).set(v);
          }
          return this.main.set(config.main);
        });
        return this;
      },
      remove: function() {
        return delete lconfig.options[command];
      },
      show: function(properties) {
        var config, filtered_config, l, len1, property;
        config = clone(lconfig);
        if (typeof properties === 'string') {
          properties = [properties];
        }
        if (!Array.isArray(properties)) {
          return config;
        }
        filtered_config = {};
        for (l = 0, len1 = properties.length; l < len1; l++) {
          property = properties[l];
          if (config[property] == null) {
            continue;
          }
          filtered_config[property] = config[property];
        }
        return filtered_config;
      }
    };
  };
  // builder.get = ->
  //   source = ctx.confx(pcommand).raw()
  //   config = {}
  //   for name, _ of source.commands
  //     config[name] = builder(name).get()
  //   config
  return builder;
};

builder_main = function(commands) {
  var builder, ctx;
  ctx = this;
  builder = {
    get: function() {
      var config;
      config = ctx.confx(commands).raw();
      return clone(config.main);
    },
    set: function(value) {
      var config;
      config = ctx.confx(commands).raw();
      if (value === void 0) {
        // Do nothing if value is undefined
        return builder;
      }
      // Unset the property if null
      if (value === null) {
        config.main = void 0;
        return builder;
      }
      if (typeof value === 'string') {
        value = {
          name: value
        };
      }
      config.main = value;
      return builder;
    }
  };
  return builder;
};

options_builder = function(commands) {
  var builder, ctx;
  ctx = this;
  builder = function(name) {
    return {
      get: function(properties) {
        var copy, j, len, option, options, property;
        // Initialize options with cascaded options
        options = builder.show();
        option = options[name];
        if (typeof properties === 'string') {
          properties = [properties];
        }
        if (!Array.isArray(properties)) {
          return option;
        }
        copy = {};
        for (j = 0, len = properties.length; j < len; j++) {
          property = properties[j];
          copy[property] = option[property];
        }
        return copy;
      },
      remove: function(name) {
        var config;
        config = ctx.confx(commands).raw();
        return delete config.options[name];
      },
      set: function() {
        var collide, config, option, ref, values;
        config = ctx.confx(commands).raw();
        values = null;
        if (arguments.length === 2) {
          values = {
            [arguments[0]]: arguments[1]
          };
        } else if (arguments.length === 1) {
          values = arguments[0];
        } else {
          throw error(['Invalid Commands Set Arguments:', 'expect 1 or 2 arguments, got 0']);
        }
        option = config.options[name] = merge(config.options[name], values);
        if (!ctx.config.extended) {
          if (!option.disabled && commands.length) {
            // Compare the current command with the options previously registered
            collide = ctx.collision[name] && ctx.collision[name].filter(function(cmd, i) {
              return commands[i] !== cmd;
            }).length === 0;
            if (collide) {
              throw error(['Invalid Option Configuration:', `option ${JSON.stringify(name)}`, `in command ${JSON.stringify(commands.join(' '))}`, `collide with the one in ${(ctx.collision[name].length === 0 ? 'application' : JSON.stringify(ctx.collision[name].join(' ')))},`, "change its name or use the extended property"]);
            }
          }
          // Associate options with their declared command
          ctx.collision[name] = commands;
        }
        // Normalize option
        option.name = name;
        if (option.type == null) {
          option.type = 'string';
        }
        if (ref = option.type, indexOf.call(types, ref) < 0) {
          throw error(['Invalid Option Configuration:', `supported options types are ${JSON.stringify(types)},`, `got ${JSON.stringify(option.type)}`, `for option ${JSON.stringify(name)}`, commands.length ? `in command ${JSON.stringify(commands.join(' '))}` : void 0]);
        }
        if (typeof option.one_of === 'string') {
          // config.shortcuts[option.shortcut] = option.name if option.shortcut and not option.disabled
          option.one_of = [option.one_of];
        }
        if (option.one_of && !Array.isArray(option.one_of)) {
          throw error(['Invalid Option Configuration:', 'option property "one_of" must be a string or an array,', `got ${option.one_of}`]);
        }
        return this;
      }
    };
  };
  builder.__proto__ = {
    get_cascaded: function() {
      var cascade_is_number, command, config, i, j, len, name, option, options, ref;
      options = {};
      config = ctx.confx().raw();
      for (i = j = 0, len = commands.length; j < len; i = ++j) {
        command = commands[i];
        ref = config.options;
        for (name in ref) {
          option = ref[name];
          if (!option.cascade) {
            continue;
          }
          cascade_is_number = typeof option.cascade === 'number';
          if (cascade_is_number && commands.length > option.cascade + i) {
            continue;
          }
          options[name] = clone(option);
        }
        config = config.commands[command];
      }
      return options;
    },
    show: function() {
      var config, name, option, options;
      // Initialize options with cascaded options
      options = builder.get_cascaded();
      for (name in options) {
        option = options[name];
        option.transient = true;
      }
      // Get app/command configuration
      config = ctx.confx(commands).raw();
      // Merge cascaded with local options
      options = merge(options, config.options);
      for (name in options) {
        option = options[name];
        if (option.disabled) {
          delete options[name];
        }
      }
      return options;
    },
    list: function() {
      return Object.keys(builder.show()).sort();
    }
  };
  return builder;
};

Parameters.prototype.confx = function(command = []) {
  var base, ctx, j, lconfig, len, name;
  ctx = this;
  if (typeof command === 'string') {
    command = [command];
  }
  // command = [...pcommand, ...command]
  lconfig = this.config;
  for (j = 0, len = command.length; j < len; j++) {
    name = command[j];
    // A new command doesn't have a config registered yet
    if ((base = lconfig.commands)[name] == null) {
      base[name] = {};
    }
    lconfig = lconfig.commands[name];
  }
  return {
    commands: commands_builder.call(this, command),
    main: builder_main.call(this, command),
    options: options_builder.call(this, command),
    get: function() {
      var _, base1, config, l, len1, option, ref, ref1, source;
      source = ctx.config;
      for (l = 0, len1 = command.length; l < len1; l++) {
        name = command[l];
        if (!source.commands[name]) {
          throw Error('Invalid Command');
        }
        // A new command doesn't have a config registered yet
        if ((base1 = source.commands)[name] == null) {
          base1[name] = {};
        }
        source = source.commands[name];
      }
      config = clone(source);
      if (command.length) {
        config.command = command;
      }
      ref = config.commands;
      for (name in ref) {
        _ = ref[name];
        config.commands[name] = this.commands(name).get();
      }
      config.options = this.options.show();
      config.shortcuts = {};
      ref1 = config.options;
      for (name in ref1) {
        option = ref1[name];
        if (option.shortcut) {
          config.shortcuts[option.shortcut] = option.name;
        }
      }
      if (config.main != null) {
        config.main = this.main.get();
      }
      return config;
    },
    set: function() {
      var hook, l, len1, values;
      values = null;
      if (arguments.length === 2) {
        values = {
          [arguments[0]]: arguments[1]
        };
      } else if (arguments.length === 1) {
        values = arguments[0];
      } else {
        throw error(['Invalid Commands Set Arguments:', 'expect 1 or 2 arguments, got 0']);
      }
      lconfig = ctx.config;
      for (l = 0, len1 = command.length; l < len1; l++) {
        name = command[l];
        // A new command doesn't have a config registered yet
        // lconfig.commands[name] ?= {}
        lconfig = lconfig.commands[name];
      }
      mutate(lconfig, values);
      hook = !command.length ? 'configure_app_set' : 'configure_commands_set';
      ctx.hook(hook, {
        config: lconfig,
        command: command,
        values: values
      }, ({config, command, values}) => {
        var k, ref, ref1, v;
        // config.name = name
        if (!command.length) {
          if (config.extended == null) {
            config.extended = false;
          }
          if (typeof config.extended !== 'boolean') {
            throw error(['Invalid Configuration:', 'extended must be a boolean,', `got ${JSON.stringify(config.extended)}`]);
          }
          config.root = true;
          if (config.name == null) {
            config.name = 'myapp';
          }
          if (Object.keys(config.commands).length) {
            if (config.command == null) {
              config.command = 'command';
            }
          }
        } else {
          if (config.name && config.name !== command.slice(-1)[0]) {
            throw error(['Incoherent Command Name:', `key ${JSON.stringify(name)} is not equal with name ${JSON.stringify(config.name)}`]);
          }
          if (config.command != null) {
            throw error(['Invalid Command Configuration:', 'command property can only be declared at the application level,', `got command ${JSON.stringify(config.command)}`]);
          }
          if (config.extended != null) {
            throw error(['Invalid Command Configuration:', 'extended property cannot be declared inside a command']);
          }
        }
        // config.command ?= command if Object.keys(config.commands).length
        // config.description ?= 'No description yet' # Shall be moved to the help plugin
        if (config.commands == null) {
          config.commands = {};
        }
        if (config.options == null) {
          config.options = {};
        }
        if (config.shortcuts == null) {
          config.shortcuts = {};
        }
        if (config.strict == null) {
          config.strict = false;
        }
        ref = config.options;
        for (k in ref) {
          v = ref[k];
          this.options(k).set(v);
        }
        ref1 = config.commands;
        for (k in ref1) {
          v = ref1[k];
          this.commands(k).set(v);
        }
        return this.main.set(config.main);
      });
      return this;
    },
    // remove: ->
    //   delete lconfig.options[command]
    raw: function() {
      return lconfig;
    }
  };
};

// ## Internal types
types = ['string', 'boolean', 'integer', 'array'];
