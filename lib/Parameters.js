// Generated by CoffeeScript 2.4.1
  // # Parameters
var Parameters, array_to_object, clone, error, is_object_literal, load, merge, pad, path, register, registry, set_default, stream, types,
  splice = [].splice,
  indexOf = [].indexOf;

registry = [];

register = function(plugin) {
  return registry.push(plugin);
};

Parameters = function(config) {
  this.registry = [];
  this.init();
  this.configure(config);
  this.configure().set(this.config);
  return this;
};

Parameters.prototype.init = (function() {});

Parameters.prototype.register = function(plugin) {
  if (!is_object_literal(plugin)) {
    throw error(['Invalid Plugin Registration:', 'plugin must consist of keys representing the hook names', 'associated with function implementing the hook,', `got ${plugin}`]);
  }
  this.registry.push(plugin);
  return this;
};

Parameters.prototype.hook = function(name, ...args) {
  var handler, j, l, len, len1, plugin, ref, ref1, res;
  ref = args, [...args] = ref, [handler] = splice.call(args, -1);
  res = null;
  for (j = 0, len = registry.length; j < len; j++) {
    plugin = registry[j];
    if (plugin[name]) {
      handler = plugin.call(this, ...args, handler);
    }
  }
  ref1 = this.registry;
  for (l = 0, len1 = ref1.length; l < len1; l++) {
    plugin = ref1[l];
    if (plugin[name]) {
      handler = plugin[name].call(this, ...args, handler);
    }
  }
  handler.call(this, ...args);
  return handler;
};

// ## `configure(config)`
Parameters.prototype.configure = function(config = {}) {
  var collision, sanitize_command, sanitize_commands, sanitize_commands_enrich, sanitize_help, sanitize_main, sanitize_options, sanitize_options_enrich;
  config = clone(config);
  this.config = config;
  // Sanitize options
  collision = {};
  sanitize_options = (config) => {
    var collide, name, option, ref, ref1, results;
    if (config.options == null) {
      config.options = {};
    }
    if (Array.isArray(config.options)) {
      // Convert from object with keys as options name to an array
      config.options = array_to_object(config.options, 'name');
    }
    ref = config.options;
    results = [];
    for (name in ref) {
      option = ref[name];
      // Prevent collision
      if (!this.config.extended) {
        if (!config.root) {
          // Compare the current command with the options previously registered
          collide = collision[name] && collision[name].filter(function(cmd, i) {
            return config.command[i] !== cmd;
          }).length === 0;
          if (collide) {
            throw error(['Invalid Option Configuration:', `option ${JSON.stringify(name)}`, `in command ${JSON.stringify(config.command.join(' '))}`, `collide with the one in ${(collision[name].length === 0 ? 'application' : JSON.stringify(collision[name].join(' ')))},`, "change its name or use the extended property"]);
          }
        }
        // Associate options with their declared command
        collision[name] = config.root ? [] : config.command;
      }
      // Normalize option
      option.name = name;
      if (option.type == null) {
        option.type = 'string';
      }
      if (ref1 = option.type, indexOf.call(types, ref1) < 0) {
        throw error(['Invalid Option Configuration:', `supported options types are ${JSON.stringify(types)},`, `got ${JSON.stringify(option.type)}`, `for option ${JSON.stringify(name)}`, Array.isArray(config.command) ? `in command ${JSON.stringify(config.command.join(' '))}` : void 0]);
      }
      if (option.shortcut) {
        config.shortcuts[option.shortcut] = option.name;
      }
      if (typeof option.one_of === 'string') {
        option.one_of = [option.one_of];
      }
      if (option.one_of && !Array.isArray(option.one_of)) {
        throw error(['Invalid Option Configuration:', 'option property "one_of" must be a string or an array,', `got ${option.one_of}`]);
      } else {
        results.push(void 0);
      }
    }
    return results;
  };
  // Sanitize main
  sanitize_main = function(config) {
    if (!config.main) {
      return config;
    }
    if (typeof config.main === 'string') {
      return config.main = {
        name: config.main
      };
    }
  };
  sanitize_command = function(command, parent) {
    if (command.strict == null) {
      command.strict = parent.strict;
    }
    command.shortcuts = {};
    if (command.extended != null) {
      throw error(['Invalid Command Configuration:', 'extended property cannot be declared inside a command']);
    }
    sanitize_main(command);
    sanitize_options(command);
    sanitize_commands(command);
    return command;
  };
  sanitize_commands = function(config) {
    var command, name, ref, results;
    if (config.commands == null) {
      config.commands = {};
    }
    if (Array.isArray(config.commands)) {
      config.commands = array_to_object(config.commands, 'name');
    }
    ref = config.commands;
    results = [];
    for (name in ref) {
      command = ref[name];
      if (command.name && command.name !== name) {
        throw error(['Incoherent Command Name:', `key ${JSON.stringify(name)} is not equal with name ${JSON.stringify(command.name)}`]);
      }
      command.name = name;
      if (command.command != null) {
        throw error(['Invalid Command Configuration:', 'command property can only be declared at the application level,', `got command ${JSON.stringify(command.command)}`]);
      }
      command.command = config.root ? [name] : [...config.command, name];
      results.push(sanitize_command(command, config));
    }
    return results;
  };
  // An object where key are command and values are object map between shortcuts and names
  if (config.name == null) {
    config.name = 'myapp';
  }
  if (config.extended == null) {
    config.extended = false;
  }
  if (typeof config.extended !== 'boolean') {
    throw error(['Invalid Configuration:', 'extended must be a boolean,', `got ${JSON.stringify(config.extended)}`]);
  }
  config.root = true;
  if (config.description == null) {
    config.description = 'No description yet';
  }
  config.shortcuts = {};
  if (config.strict == null) {
    config.strict = false;
  }
  sanitize_main(config);
  sanitize_options(config);
  sanitize_commands(config);
  sanitize_help = function(config) {
    var command;
    if (Object.keys(config.commands).length) {
      if (config.command == null) {
        config.command = 'command';
      }
      command = sanitize_command({
        name: 'help',
        description: `Display help information about ${config.name}`,
        command: ['help'],
        main: {
          name: 'name',
          description: 'Help about a specific command'
        },
        help: true,
        route: path.resolve(__dirname, './routes/help') // config.help.route
      }, config);
      return config.commands[command.name] = merge(command, config.commands[command.name]);
    }
  };
  sanitize_help(this.config);
  // Second pass, add help options and set default
  sanitize_options_enrich = function(config) {
    var _, command, ref, results;
    // No "help" option for command "help"
    if (config.root || !config.help) {
      config.options['help'] = merge(config.options['help'], {
        name: 'help',
        shortcut: 'h',
        description: 'Display help information',
        type: 'boolean',
        help: true
      });
      if (config.options['help'].shortcut) {
        config.shortcuts[config.options['help'].shortcut] = config.options['help'].name;
      }
    }
    ref = config.commands;
    results = [];
    for (_ in ref) {
      command = ref[_];
      results.push(sanitize_options_enrich(command));
    }
    return results;
  };
  sanitize_options_enrich(this.config);
  sanitize_commands_enrich = function(config) {
    var command, name, ref, results;
    ref = config.commands;
    results = [];
    for (name in ref) {
      command = ref[name];
      if (command.description == null) {
        command.description = `No description yet for the ${command.name} command`;
      }
      results.push(sanitize_commands_enrich(command, config));
    }
    return results;
  };
  sanitize_commands_enrich(this.config);
  return this.config;
};

// ## Method `parse([arguments])`

// Convert an arguments list to a parameters object.

// * `arguments`: `[string] | string | process` The arguments to parse into parameters, accept the [Node.js process](https://nodejs.org/api/process.html) instance or an [argument list](https://nodejs.org/api/process.html#process_process_argv) provided as an array or a string, optional.
// * `options`: `object` Options used to alter the behavior of the `stringify` method.
//   * `extended`: `boolean` The value `true` indicates that the parameters are returned in extended format, default to the configuration `extended` value which is `false` by default.
// * Returns: `object | [object]` The extracted parameters, a literal object in default flatten mode or an array in extended mode.
Parameters.prototype.parse = function(argv = process, options = {}) {
  var command_params, full_params, index, j, k, len, params, parse, v;
  if (options.extended == null) {
    options.extended = this.config.extended;
  }
  index = 0;
  // Remove node and script argv elements
  if (argv === process) {
    index = 2;
    argv = argv.argv;
  } else if (typeof argv === 'string') {
    argv = argv.split(' ');
  } else if (!Array.isArray(argv)) {
    throw error(['Invalid Arguments:', 'parse require arguments or process as first argument,', `got ${JSON.stringify(process)}`]);
  }
  // Extracted parameters
  full_params = [];
  parse = (config, command) => {
    var _, err, helping, j, key, leftover, len, main, option, params, ref, ref1, ref2, shortcut, type, value, values;
    full_params.push(params = {});
    if (command != null) {
      // Add command name provided by parent
      params[this.config.command] = command;
    }
    // Read options
    while (true) {
      if (argv.length === index || argv[index][0] !== '-') {
        break;
      }
      key = argv[index++];
      shortcut = key[1] !== '-';
      key = key.substring((shortcut ? 1 : 2), key.length);
      if (shortcut) {
        shortcut = key;
      }
      if (shortcut) {
        key = config.shortcuts[shortcut];
      }
      option = (ref = config.options) != null ? ref[key] : void 0;
      if (!shortcut && config.strict && !option) {
        err = error(['Invalid Argument:', `the argument ${(shortcut ? "-" : "--")}${key} is not a valid option`]);
        err.command = full_params.slice(1).map((params) => {
          return params[this.config.command];
        });
        throw err;
      }
      if (shortcut && !option) {
        throw error(['Invalid Shortcut Argument:', `the "-${shortcut}" argument is not a valid option`, Array.isArray(config.command) ? `in command "${config.command.join(' ')}"` : void 0]);
      }
      // Auto discovery
      if (!option) {
        type = argv[index] && argv[index][0] !== '-' ? 'string' : 'boolean';
        option = {
          name: key,
          type: type
        };
      }
      switch (option.type) {
        case 'boolean':
          params[key] = true;
          break;
        case 'string':
          value = argv[index++];
          if (!((value != null) && value[0] !== '-')) {
            throw error(['Invalid Option:', `no value found for option ${JSON.stringify(key)}`]);
          }
          params[key] = value;
          break;
        case 'integer':
          value = argv[index++];
          if (!((value != null) && value[0] !== '-')) {
            throw error(['Invalid Option:', `no value found for option ${JSON.stringify(key)}`]);
          }
          params[key] = parseInt(value, 10);
          break;
        case 'array':
          value = argv[index++];
          if (!((value != null) && value[0] !== '-')) {
            throw error(['Invalid Option:', `no value found for option ${JSON.stringify(key)}`]);
          }
          if (params[key] == null) {
            params[key] = [];
          }
          params[key].push(...value.split(','));
      }
    }
    // Check if help is requested
    // TODO: this doesnt seem right, also, the test in help.parse seems wrong as well
    helping = false;
    ref1 = config.options;
    for (_ in ref1) {
      option = ref1[_];
      if (option.help !== true) {
        continue;
      }
      if (params[option.name]) {
        helping = true;
      }
    }
    if (helping) {
      return params;
    }
    ref2 = config.options;
    // Check against required options
    for (_ in ref2) {
      option = ref2[_];
      if (option.required) {
        if (!(helping || (params[option.name] != null))) {
          throw error(['Required Option Argument:', `the "${option.name}" option must be provided`]);
        }
      }
      if (option.one_of) {
        values = params[option.name];
        if (!option.required && values !== void 0) {
          if (!Array.isArray(values)) {
            values = [values];
          }
          for (j = 0, len = values.length; j < len; j++) {
            value = values[j];
            if (indexOf.call(option.one_of, value) < 0) {
              throw error(['Invalid Argument Value:', `the value of option "${option.name}"`, `must be one of ${JSON.stringify(option.one_of)},`, `got ${JSON.stringify(value)}`]);
            }
          }
        }
      }
    }
    // We still have some argument to parse
    if (argv.length !== index) {
      // Store the full command in the return array
      leftover = argv.slice(index);
      if (config.main) {
        params[config.main.name] = leftover;
      } else {
        command = argv[index++];
        if (!config.commands[command]) {
          // Validate the command
          throw error(['Invalid Argument:', `fail to interpret all arguments "${leftover.join(' ')}"`]);
        }
        // Parse child configuration
        parse(config.commands[command], command);
      }
    }
    // Command mode but no command are found, default to help
    // Default to help is help property is set and no command is found in user args
    // Happens with global options without a command
    if (Object.keys(config.commands).length && !command) {
      params[this.config.command] = 'help';
    }
    // Check against required main
    main = config.main;
    if (main && main.required) {
      if (params[main.name] == null) {
        throw error(['Required Main Argument:', `no suitable arguments for ${JSON.stringify(main.name)}`]);
      }
    }
    return params;
  };
  // Start the parser
  parse(this.config, null);
  if (!options.extended) {
    params = {};
    if (Object.keys(this.config.commands).length) {
      params[this.config.command] = [];
    }
    for (j = 0, len = full_params.length; j < len; j++) {
      command_params = full_params[j];
      for (k in command_params) {
        v = command_params[k];
        if (k === this.config.command) {
          params[k].push(v);
        } else {
          params[k] = v;
        }
      }
    }
  } else {
    params = full_params;
  }
  // Enrich params with default values
  set_default(this.config, params);
  return params;
};

// ## Method `stringify(command, [options])`

// Convert a parameters object to an arguments array.

// * `params`: `object` The parameter object to be converted into an array of arguments, optional.
// * `options`: `object` Options used to alter the behavior of the `stringify` method.
//   * `extended`: `boolean` The value `true` indicates that the parameters are provided in extended format, default to the configuration `extended` value which is `false` by default.
//   * `script`: `string` The JavaScript file being executed by the engine, when present, the engine and the script names will prepend the returned arguments, optional, default is false.
// * Returns: `array` The command line arguments.
Parameters.prototype.stringify = function(params, options = {}) {
  var argv, keys, stringify;
  argv = options.script ? [process.execPath, options.script] : [];
  if (options.extended == null) {
    options.extended = this.config.extended;
  }
  if (!is_object_literal(options)) {
    throw error(['Invalid Stringify Arguments:', '2nd argument option must be an object,', `got ${JSON.stringify(options)}`]);
  }
  keys = {};
  // In extended mode, the params array will be truncated
  // params = merge params unless extended
  set_default(this.config, params);
  if (typeof params[this.config.command] === 'string') {
    // Convert command parameter to a 1 element array if provided as a string
    params[this.config.command] = [params[this.config.command]];
  }
  // Stringify
  stringify = (config, lparams) => {
    var _, command, has_child_commands, j, key, len, option, ref, results, val, value;
    ref = config.options;
    for (_ in ref) {
      option = ref[_];
      key = option.name;
      keys[key] = true;
      value = lparams[key];
      if (option.required && (value == null)) {
        // Validate required value
        throw error(['Required Option Parameter:', `the "${key}" option must be provided`]);
      }
      // Validate value against option "one_of"
      if ((value != null) && option.one_of) {
        if (!Array.isArray(value)) {
          value = [value];
        }
        for (j = 0, len = value.length; j < len; j++) {
          val = value[j];
          if (indexOf.call(option.one_of, val) < 0) {
            throw error(['Invalid Parameter Value:', `the value of option "${option.name}"`, `must be one of ${JSON.stringify(option.one_of)},`, `got ${JSON.stringify(val)}`]);
          }
        }
      }
      // Serialize
      if (value) {
        switch (option.type) {
          case 'boolean':
            argv.push(`--${key}`);
            break;
          case 'string':
          case 'integer':
            argv.push(`--${key}`);
            argv.push(`${value}`);
            break;
          case 'array':
            argv.push(`--${key}`);
            argv.push(`${value.join(',')}`);
        }
      }
    }
    if (config.main) {
      value = lparams[config.main.name];
      if (config.main.required && (value == null)) {
        throw error(['Required Main Parameter:', `no suitable arguments for ${JSON.stringify(config.main.name)}`]);
      }
      if (value != null) {
        if (!Array.isArray(value)) {
          throw error(['Invalid Parameter Type:', `expect main to be an array, got ${JSON.stringify(value)}`]);
        }
        keys[config.main.name] = value;
        argv = argv.concat(value);
      }
    }
    // Recursive
    has_child_commands = options.extended ? params.length : Object.keys(config.commands).length;
    if (has_child_commands) {
      command = options.extended ? params[0][this.config.command] : params[this.config.command].shift();
      if (!config.commands[command]) {
        throw error(['Invalid Command Parameter:', `command ${JSON.stringify(command)} is not registed,`, `expect one of ${JSON.stringify(Object.keys(config.commands).sort())}`, Array.isArray(config.command) ? `in command ${JSON.stringify(config.command.join(' '))}` : void 0]);
      }
      argv.push(command);
      keys[this.config.command] = command;
      // Stringify child configuration
      stringify(config.commands[command], options.extended ? params.shift() : lparams);
    }
    if (options.extended || !has_child_commands) {
// Handle params not defined in the configuration
// Note, they are always pushed to the end and associated with the deepest child
      results = [];
      for (key in lparams) {
        value = lparams[key];
        if (keys[key]) {
          continue;
        }
        if (this.config.strict) {
          throw Error(['Invalid Parameter:', `the property --${key} is not a registered argument`].join(' '));
        }
        if (typeof value === 'boolean') {
          if (value) {
            results.push(argv.push(`--${key}`));
          } else {
            results.push(void 0);
          }
        } else if (typeof value === 'undefined' || value === null) {

        } else {
          // nothing
          argv.push(`--${key}`);
          results.push(argv.push(`${value}`));
        }
      }
      return results;
    }
  };
  stringify(this.config, options.extended ? params.shift() : params);
  return argv;
};

// ## Method `helping(params)`

// Determine if help was requested by returning zero to n commands if help is requested or null otherwise.

// * `params`: `[object] | object` The parameter object parsed from arguments, an object in flatten mode or an array in extended mode, optional.
// * Returns: `array | null` The formatted help to be printed.
Parameters.prototype.helping = function(params, options = {}) {
  var commands, helping, leftover, search;
  params = clone(params);
  if (options.extended == null) {
    options.extended = this.config.extended;
  }
  if (!options.extended) {
    if (!is_object_literal(params)) {
      throw error(["Invalid Arguments:", "`helping` expect a params object as first argument", "in flatten mode,", `got ${JSON.stringify(params)}`]);
    }
  } else {
    if (!(Array.isArray(params) && !params.some(function(cparams) {
      return !is_object_literal(cparams);
    }))) {
      throw error(["Invalid Arguments:", "`helping` expect a params array with literal objects as first argument", "in extended mode,", `got ${JSON.stringify(params)}`]);
    }
  }
  // Extract the current commands from the parameters arguments
  if (!options.extended) {
    if (params[this.config.command] && !Array.isArray(params[this.config.command])) {
      throw error(['Invalid Arguments:', `parameter ${JSON.stringify(this.config.command)} must be an array in flatten mode,`, `got ${JSON.stringify(params[this.config.command])}`]);
    }
    //unless Array.isArray params[@config.command]
    // throw Error 'Invalid Argument' if typeof params[@config.command] is 'string'
    // params[@config.command] = [params[@config.command]] if typeof params[@config.command] is 'string'
    commands = params[this.config.command] || [];
  } else {
    commands = params.slice(1).map((cparams) => {
      return cparams[this.config.command];
    });
  }
  // Handle help command
  // if this is the help command, transform the leftover into a new command
  if (commands.length && this.config.commands && this.config.commands[commands[0]].help) {
    helping = true;
    // Note, when argv equals ['help'], there is no leftover and main is null
    leftover = !options.extended ? params[this.config.commands[commands[0]].main.name] : params[1][this.config.commands[commands[0]].main.name];
    if (leftover) {
      return leftover;
    } else {
      return [];
    }
  }
  // Handle help option:
  // search if the help option is provided and for which command it apply
  search = function(config, commands, params) {
    var command, cparams;
    cparams = !options.extended ? params : params.shift();
    // Search the help option
    helping = Object.values(config.options).filter(function(options) {
      return options.help;
    // Check if it is present in the parsed parameters
    }).some(function(options) {
      return cparams[options.name] != null;
    });
    if (helping) {
      if (options.extended && commands.length) {
        throw error(['Invalid Argument:', '`help` must be associated with a leaf command']);
      }
      return true;
    }
    if (!(commands != null ? commands.length : void 0)) {
      // Helping is not requested and there are no more commands to search
      return false;
    }
    command = commands.shift();
    if (options.extended && params.length === 0) {
      return false;
    }
    config = config.commands[command];
    return search(config, commands, params);
  };
  helping = search(this.config, clone(commands), params);
  if (helping) {
    return commands;
  } else {
    return null;
  }
};

// ## Method `help(command)`

// Format the configuration into a readable documentation string.

// * `command`: `[string] | string` The string or array containing the command name if any, optional.
// * Returns: `string` The formatted help to be printed.
Parameters.prototype.help = function(commands = [], options = {}) {
  var _, cmd, command, config, configs, content, description, has_help_command, has_help_option, i, j, l, len, len1, len2, line, m, name, option, ref, ref1, ref2, ref3, ref4, shortcut, synopsis;
  if (typeof commands === 'string') {
    commands = commands.split(' ');
  }
  if (!Array.isArray(commands)) {
    throw error(['Invalid Help Arguments:', 'expect commands to be an array as first argument,', `got ${JSON.stringify(commands)}`]);
  }
  config = this.config;
  configs = [config];
  for (i = j = 0, len = commands.length; j < len; i = ++j) {
    command = commands[i];
    config = config.commands[command];
    if (!config) {
      throw error(['Invalid Command:', `argument "${commands.slice(0, i + 1).join(' ')}" is not a valid command`]);
    }
    configs.push(config);
  }
  // Init
  content = [];
  content.push('');
  // Name
  content.push('NAME');
  name = configs.map(function(config) {
    return config.name;
  }).join(' ');
  description = configs[configs.length - 1].description;
  content.push(`    ${name} - ${description}`);
  // Synopsis
  content.push('');
  content.push('SYNOPSIS');
  synopsis = [];
  for (i = l = 0, len1 = configs.length; l < len1; i = ++l) {
    config = configs[i];
    synopsis.push(config.name);
    // Find if there are options other than help
    if (Object.values(config.options).some(function(option) {
      return !option.help;
    })) {
      synopsis.push(`[${config.name} options]`);
    }
    // Is current config
    if (i === configs.length - 1) {
      // There are more subcommand
      if (Object.keys(config.commands).length) {
        synopsis.push(`<${this.config.command}>`);
      } else if (config.main) {
        synopsis.push(`{${config.main.name}}`);
      }
    }
  }
  content.push('    ' + synopsis.join(' '));
  ref = configs.slice(0).reverse();
  // Options
  for (m = 0, len2 = ref.length; m < len2; m++) {
    config = ref[m];
    if (Object.keys(config.options).length || config.main) {
      content.push('');
      if (configs.length === 1) {
        content.push("OPTIONS");
      } else {
        content.push(`OPTIONS for ${config.name}`);
      }
    }
    if (Object.keys(config.options).length) {
      ref1 = config.options;
      for (_ in ref1) {
        option = ref1[_];
        shortcut = option.shortcut ? `-${option.shortcut} ` : '';
        line = '    ';
        line += `${shortcut}--${option.name}`;
        line = pad(line, 28);
        if (line.length > 28) {
          content.push(line);
          line = ' '.repeat(28);
        }
        line += option.description || `No description yet for the ${option.name} option.`;
        if (option.required) {
          line += ' Required.';
        }
        content.push(line);
      }
    }
    if (config.main) {
      line = '    ';
      line += `${config.main.name}`;
      line = pad(line, 28);
      if (line.length > 28) {
        content.push(line);
        line = ' '.repeat(28);
      }
      line += config.main.description || `No description yet for the ${config.main.name} option.`;
      content.push(line);
    }
  }
  // Command
  config = configs[configs.length - 1];
  if (Object.keys(config.commands).length) {
    content.push('');
    content.push('COMMANDS');
    ref2 = config.commands;
    for (_ in ref2) {
      command = ref2[_];
      line = [`${command.name}`];
      line = pad(`    ${line.join(' ')}`, 28);
      if (line.length > 28) {
        content.push(line);
        line = ' '.repeat(28);
      }
      line += command.description || `No description yet for the ${command.name} command.`;
      content.push(line);
    }
    // Detailed command information
    if (options.extended) {
      ref3 = config.commands;
      for (_ in ref3) {
        command = ref3[_];
        content.push('');
        content.push(`COMMAND "${command.name}"`);
        // Raw command, no main, no child commands
        if (!Object.keys(command.commands).length && !((ref4 = command.main) != null ? ref4.required : void 0)) {
          line = `${command.name}`;
          line = pad(`    ${line}`, 28);
          if (line.length > 28) {
            content.push(line);
            line = ' '.repeat(28);
          }
          line += command.description || `No description yet for the ${command.name} command.`;
          content.push(line);
        }
        // Command with main
        if (command.main) {
          line = `${command.name} {${command.main.name}}`;
          line = pad(`    ${line}`, 28);
          if (line.length > 28) {
            content.push(line);
            line = ' '.repeat(28);
          }
          line += command.main.description || `No description yet for the ${command.main.name} option.`;
          content.push(line);
        }
        // Command with child commands
        if (Object.keys(command.commands).length) {
          line = [`${command.name}`];
          if (Object.keys(command.options).length) {
            line.push(`[${command.name} options]`);
          }
          line.push(`<${command.command}>`);
          content.push('    ' + line.join(' '));
          commands = Object.keys(command.commands);
          if (commands.length === 1) {
            content.push(`    Where command is ${Object.keys(command.commands)}.`);
          } else if (commands.length > 1) {
            content.push(`    Where command is one of ${Object.keys(command.commands).join(', ')}.`);
          }
        }
      }
    }
  }
  // Add examples
  config = configs[configs.length - 1];
  has_help_option = Object.values(config.options).some(function(option) {
    return option.name === 'help';
  });
  has_help_command = Object.values(config.commands).some(function(command) {
    return command.name === 'help';
  });
  has_help_option = true;
  content.push('');
  content.push('EXAMPLES');
  cmd = configs.map(function(config) {
    return config.name;
  }).join(' ');
  if (has_help_option) {
    line = pad(`    ${cmd} --help`, 28);
    if (line.length > 28) {
      content.push(line);
      line = ' '.repeat(28);
    }
    line += 'Show this message';
    content.push(line);
  }
  if (has_help_command) {
    line = pad(`    ${cmd} help`, 28);
    if (line.length > 28) {
      content.push(line);
      line = ' '.repeat(28);
    }
    line += 'Show this message';
    content.push(line);
  }
  content.push('');
  return content.join('\n');
};

// ## `load(module)`

// * `module`   
//   Name of the module to load, required.

// Load and return a module, use `require.main.require` by default but can be
// overwritten by the `load` options passed in the configuration.
Parameters.prototype.load = function(module) {
  if (typeof module !== 'string') {
    throw Error(['Invalid Load Argument:', 'load is expecting string,', `got ${JSON.stringify(module)}`].join(' '));
  }
  if (this.config.load) {
    if (typeof this.config.load === 'string') {
      return load(this.config.load)(module);
    } else {
      return this.config.load(module);
    }
  } else {
    return load(module);
  }
};

// ## Export
module.exports = Parameters;

// ## Dependencies
pad = require('pad');

path = require('path');

stream = require('stream');

load = require('./utils/load');

error = require('./utils/error');

({clone, merge, is_object_literal} = require('mixme'));

// ## Internal types
types = ['string', 'boolean', 'integer', 'array'];

// ## Utils

// Convert an array to an object
array_to_object = function(elements, key) {
  var element, j, len, opts;
  opts = {};
  for (j = 0, len = elements.length; j < len; j++) {
    element = elements[j];
    opts[element[key]] = element;
  }
  return opts;
};

// Given a configuration, apply default values to the parameters
set_default = function(config, params, tempparams = null) {
  var _, command, name1, option, ref;
  if (tempparams == null) {
    tempparams = merge(params);
  }
  if (Object.keys(config.commands).length) {
    command = tempparams[config.command];
    if (Array.isArray(command)) {
      command = tempparams[config.command].shift();
    }
    // We are not validating if the command is valid, it may not be set if help option is present
    // throw Error "Invalid Command: \"#{command}\"" unless config.commands[command]
    if (config.commands[command]) {
      params = set_default(config.commands[command], params, tempparams);
    }
  }
  ref = config.options;
  for (_ in ref) {
    option = ref[_];
    if (option.default != null) {
      if (params[name1 = option.name] == null) {
        params[name1] = option.default;
      }
    }
  }
  return params;
};
